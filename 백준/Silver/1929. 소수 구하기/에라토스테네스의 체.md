# 에라토스테네스의 체

[위키](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)

> 수학에서 에라토스테네스의 체는 소수를 찾는 빠르고 쉬운 방법이다. 고대 그리스 수학자 에라토스테네스가 발견하였다. 

## 소수 판정법

그 전에, **소수 판정법** 을 먼저 알아보자.

_Ex. 119는 소수인가?_

위와 같은 문제가 주어졌을 때, 우린 어떻게 판단할까?

- Brute force
  - 119 보다 작은 모든 수로 나누어본다. (당연히 1은 제외함.)
  - 매우 비효율적
  - 조금 더 나아간 생각으로, 119 보다 작은 **소수**들만으로 check 해본다고 해도 똑같이 비효율적이다.
 
- 소수 판정법
  - sqrt(119) 보다 작거나 같은 모든 **소수**로 나누어본다.
  - sqrt(119) 는 대략 10.xx 이므로, {2, 3, 5, 7} 으로만 나누어보면 된다.

이처럼 주어진 **N** 이 소수인지 궁금하다면, `p <= sqrt(N)` 인 소수 p들을 가지고 N을 나눠보면 된다.

왜? 어떻게 가능한걸까?

직관적으로 따져보자.

```
119가 소수인지 검사하려고 한다.

2의 배수인지 검사해본다.
3의 배수인지 검사해본다.
5의 배수인지 검사해본다.
7의 배수인지 검사해본다.

11의 배수인지 검사할 필요가 있을까?
없다.
왜?

11 x 1은 1의 배수다.
11 x 2는 2의 배수다.
11 x 3은 3의 배수다.
11 x 4는 4의 배수다.
11 x 5는 5의 배수다.
...
11 x 10 까지는 전부 이미 그 전에 검사해 본 셈이다.

즉 11의 배수인지 검사할 때, 우리가 새로 처음 검사하는 항목은 11 x 11 이상부터이다.
그러나 11 x 11 = 121
이미 119를 초과하는 숫자다.

그런 의미에서 N이 소수인지 판정하고자 할 때, p <= sqrt(N) 인 소수 p로만 검사해보면 되는 것이다.
sqrt(N) < p 인 소수 p로 검사해봤자, 이미 그보다 작은 소수들로 검사할 때 다 했던 수들을 또 체크하는 셈만 된다.
```

## 에라토스테네스의 체

우리는 이러한 **소수 판정법**을 적용하면서도, 지금 문제를 풀기 위해 **에라토스테네스의 체** 를 이용할 필요가 있다.

지금 문제는 대상 숫자 하나만 검사하라는게 아니라 수의 범위를 주고, 그 안에 포함된 소수들을 모두 출력하라고 하고 있기 때문이다.

- 에라토스테네스의 체
  - 119 이하의 자연수 중에 소수만 모두 찾아내보자.
  - 119 까지 모든 수가 나열되어있다.
  - 119 보다 작은 **소수**들의 배수를 모두 지우자. (주의! 본인은 삭제 X)
    - (2 제외한) 2의 배수들을 모조리 지운다.
    - (3 제외한) 3의 배수들을 모조리 지운다.
    - (5 제외한) 5의 배수들을 모조리 지운다.
    - ...
  - 위에서 소수 판정법을 직관적으로 따져본 것처럼, 여기서도 마찬가지로 `p <= sqrt(N)`인 p까지만 가면 된다.
  - 즉 11의 배수는 지우려고 해봤자 이미 다 지워져있고, 121 부터 살아있을텐데, 이미 범위를 넘어선다.

### 구현 points

구현할 때 섬세하게 봐야하는 포인트들이 있다.

- 수들을 어떻게 저장할까? `std::map` 으로 할까?
- `p <= sort(N)` 인 p 까지만 검사하도록 어떻게 잡을까?
- 4의 배수를 지운다거나, 6의 배수를 지운다거나, 소수가 아닌 수로 검사할 필요가 없는데, 어떻게 제외시킬까?
- 그저 'N 이하'의 수가 아니라, 'M 이상 N 이하' 로 범위가 들어온다. 어떻게 처리할까? 

이런 점들을 잘 고려해서 구현하면, 생각보다 어렵지 않게 구현할 수 있다!

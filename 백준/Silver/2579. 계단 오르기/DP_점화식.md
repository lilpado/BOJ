# DP : Dynamic programming (동적 계획법)

[DP란 무엇인가.](https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95) 정말 감히 쉽게 말하자면 **'재활용'** 이다.

이미 한 번 값을 구한 적 있는 연산이라면, 굳이 다시 수행하지 않고 이전의 결과를 '재활용' 하여 총 연산 속도를 줄인다.

그렇게 알고리듬의 성능을 개선한다. (흡사 분할-정복)

## 점화식?

이렇게 DP를 이용하는 알고리듬의 경우, '이미 한 번 결과를 냈던 연산 step'이 있기 마련이다.

- 즉 `Kth step` **점화식** 으로 표현되고는 한다.
- 그렇다면 해당 문제의 점화식은 어떻게 설정할 것인가?
- 그것이 문제를 해결할 수 있는 열쇠다.


## 나의 풀이 과정

### 점화식
가장 먼저 '점화식'을 찾고자 노력했다.

> 우선 `count()`가 해당 `Kth step` 까지의 최댓값을 반환해주는 함수라고 치자.

#### 1st try
- '대충 `K`일 때, `max(count(K-1), count(K-2)) + Kth 값` 
- 근데 문제는 `count(K-1)`의 값을 구할 때, 그 때 'K-1'과 'K-2'가 연속되는 경우는 '제외'해야한다.
- 만약 연속된다면 최종적으로는 'K', 'K-1', 'K-2'가 연속되므로 못쓴다.
- 이게 복잡하다.. 어떻게 해결할까?

`count(K-1)`도 뭔가 쪼개야 되는 것을 느꼈다.

#### 2nd try
- `K`일 때, `max(count(K-2), count(K-3) + K-1th 값) + Kth 값`
- `count(K-1)`를 `count(K-3) + K-1th 값` 으로 쪼개주었다.
- 잘 생각해보면 'K-2'가 포함되지 않는 `count(K-1)`를 계산하는 것임을 알 수 있다! (우리가 필요했던 '제외')

### DP
자 여기까지 생각했으면 단순히 '재귀함수'로 문제는 풀 수 있다.

그러나 당연하게도 '시간 초과'가 뜰 것이다.

이제 'DP(동적 계획법)'을 알아낼 차례다.

- 배열을 하나 더 만들어서 이전의 값들을 다 저장해놓자.
- 음... '동적'으로 테스트 인풋들을 받을 때마다 (계단 Kth step 마다) 바로바로 연산하는 재귀함수를 호출하고, 저장해볼까?
- 인풋 다 받고나면 `1~N` 까지 모든 step의 `count(K)` 가 저장된다.

> 해결완료!

# 따져볼 점

- 시간 제한 2초, 메모리 제한 256MB
- 1 <= N, M <= 100,000
- 탐색 방법
  - 숫자로 문자 값 탐색
  - 문자로 숫자 값 탐색
- 정렬을 하지 않고, 도감에 입력할 당시 순번을 유지
- 도감 특성 상 중복 X

## 구현 포인트

1. 자료구조 선택
2. 탐색 알고리듬

> `int : string` 타입의 `STL map`을 떠올렸다.
- 문자에 따라 정렬된 idx 가 아니라, 지정 순번을 유지해야되니까!
- 해시를 사용해서 mapping 된 방식으로 탐색할 수 있으니까!

```
Ex. 순번 입력 탐색
- 숫자가 입력되면 숫자임을 인지한다.
- 해시를 통해서 문자열 값을 바로 반환한다.
```

여기까지는 쉽게 떠오른다.
하지만 '문자열 입력 -> 순번 탐색'은 어떻게 진행할까?
`STL map`에서 `value -> key` 탐색은 따로 제공되지 않는다...
- 선형 탐색 시 : N x M = 100,000 x 100,000 으로 시간 제한에 걸릴 것이다.
- 이진 탐색? : 어떤걸 기준으로 어떻게 이진 탐색을 할 것인가... 복잡해진다.

다시 생각해보면, 포켓몬 도감의 크기는 `N = 100,000` 정도의 크기다.
이는 '메모리 제한 256MB'에 비하면 별로 크지 않다고 생각해볼 수 있다.
이러한 문제의 조건 덕분에 다른 방법이 있다.

> map<int, string> 그리고 map<string, int> 두 개를 만드는 것이다.

```
도감 생성 시 두개를 만든다.
1. int : string
2. string : int

탐색 시 입력 값이 int냐, string이냐에 따라 선택해서 진행한다.
1. int 입력 -> map<int, string> 에서 탐색
2. string 입력 -> map<string, int> 에서 탐색
```

## 정리

정리하자면, map은 `key : value` 형 자료구조이다.

내부적으로는 'key' 값을 기준으로 하는 Red-Black Tree 이다.

- key로 value를 탐색하는 것은 빠르고 편리하다. (자체 이진탐색)
- value로 key를 탐색하는 것은 지원되지 않으므로, 우리가 brute-force 식 탐색을 해야한다.
- **만약 value로 key를 탐색하는 작업이 많을 것 같으면, 차라리 뒤집은 map을 하나 더 저장해놔라.**


# BFS 풀이

물론 문제 분류는 `DP - Dynamic Programming` 이었슴다.

하지만 저는 문제를 읽다보니 **'아, N에서 1까지 가는 길찾기!'** 로 느꼈슴다.

시간 제한을 따져봐도 입력 값이 `N <= 1,000,000` 으로 제한된 덕분에 될 것 같다는 생각이 들었슴다.

## 메모리 초과

하지만 첫 제출 시 99%에서 메모리 초과가 났음다.

'아.. 이거 간당간당하게 안되는구나' 를 느꼈음다.

그럼 지금 상태에서 뭘 바꿀까요?

- 'queue<struct> 형태에서 queue<int> 로 어떻게든 알고리듬을 바꿔볼까?' : 답이 없었음다.
- '길찾기를 하는 와중에 중복된 숫자가 계속 나오네? 중복을 없애는 방법을 찾아보자.' : 좋은 방향이었씀다.

## 중복 줄이기

역시 든든 국밥은 'flag를 담을 배열'을 잡아두는 것이었씀다.

- N이 1,000,000 이라고 해도 `1 byte * 1,000,000 = 1MB` 뿐이라 좋다고 생각했슴다.
- 1MB 투자하고, 중복된 숫자일 경우 큐에 담지 않는다? 이거 못 참습니다.

> GOOD !

# 수의 크기

아무리 `long long` 타입으로 해도, n = 1000 에 가까워지면 수가 너무 커져서 저장하지 못하게 된다.

따라서 문제의 출력 조건에서 요구하는 `% 10007`을 사실 데이터를 저장하는 과정에서부터 써야한다.

## 모듈러 분배 법칙 - 아이디어

우선 데이터 저장 과정 중에 `% 10007`을 해도 정말 우리가 원하던대로 똑같이 저장이 될까?

- 큰 수 원본을 저장할 수는 없겠지만, 문제에서 출력을 요구하는 `% 10007` 나머지 값이랑은 같은 수가 저장된다.
- 수를 다 더하고 나서 마지막에 `% 10007`을 하나, 더하기 전부터 `% 10007`을 하고나서 더하나 같은 값이 나오기 때문이다.
- 신기하죠? 이것이 '모듈러 분배 법칙'이다.

## 모듈러 분배 법칙 - 합동식

- 합동식은 두 수의 차이가 어떤 수의 배수일 때 그 두 수를 '합동'이라고 한다.
- 이것을 좀 더 구체적으로 설명하면, "a와 b가 있을 때, (a - b)가 어떤 정수 n의 배수이면 a와 b는 모듈러 n에서 합동이다." 
- 주로 나머지 연산에 쓰인다. 예를 들어 12와 26의 차는 14로, 7의 배수이다.
- 12와 26을 나눈 나머지는 각각 5와 5이다. 
- 12와 26은 모듈러 7에서 합동이다. 즉, 12 ≡ 26 (mod 7) 이다.

> 두 수(a, b)의 차가 어떤 수 n의 배수일 때, 우리는 그 두 수(a, b)를 `mod n` 에서 '합동'이라고 부른다.

## 모듈러 분배 법칙 - 개념

_(a + b) mod c = (a mod c + b mod c) mod c_

- 모듈러 분배 법칙은 합동식을 이용하여 곱셈과 덧셈을 바꿀 수 있는 규칙이다. 
- 예를 들어서, '(a + b)를 c로 나눈 나머지'는 'a를 c로 나눈 나머지와 b를 c로 나눈 나머지의 합을 다시 c로 나눈 나머지'와 같다.
- 즉, (a + b) mod c = (a mod c + b mod c) mod c이다.

```
간단한 예시에 적용해보자.

a = 8이고 b = 5라고 하자. 우리는 (8 + 5)를 7로 나눈 나머지를 계산하고 싶다.

첫 번째로, (8 + 5)는 13이다. 이것을 7로 나누면 나머지는 6이다.

모듈러 분배 법칙에 따르면, 이는 (8 mod 7 + 5 mod 7)를 7로 나눈 나머지와 같다.
8을 7로 나눈 나머지는 1이고, 5를 7로 나눈 나머지는 5이다.
따라서 (1 + 5) mod 7을 계산하면 6이다.

결과적으로 (8 + 5) mod 7 = 6이다.
```

이런식으로 우리는 '모듈러 분배 법칙'을 알고있다면,

특히 프로그래밍 시 자료의 크기가 자료형 범위를 넘어가는 경우에 적용하여 효율적으로 작성할 수 있다.

## 모듈러 분배 법칙 - 증명

_(a + b) mod c = (a mod c + b mod c) mod c_

```
a = q1 x c + r1
b = q2 x c + r2
이다.

이를 왼쪽 식에 대입해보면
(q1 x c + r1 + q2 x c + r2) mod c
= ((q1 + q2) x c + r1 + r2) mod c

여기서 (q1 + q2) 는 몫에 해당하고 결국 남는 것은
(r1 + r2) mod c

이때 위에서
r1 = a mod c
r2 = b mod c
이므로

결국
(a + b) mod c = (a mod c + b mod c) mod c
```


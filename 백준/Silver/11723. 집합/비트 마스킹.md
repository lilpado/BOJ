# 비트 마스킹을 알고있니?

## 문제

공집합 S에 대해 이런 연산들을 할거야.
 - `add x`
 - `remove x`
 - `check x`
 - `toggle x`
 - `all`
 - `empty`

하지만 **시간 제한 1.5초**, **메모리 제한 4 MB** 란다.

## STL set

> 무턱대고 집합이니까 STL `std::set`을 써보자.

연산의 수 `M`은 300만까지 될 수 있다. 만약 `all`과 `empty`만 번갈아가며 300만번 수행하는 case라면?

- `std::set`은 **red-black** 트리 기반으로 만들어졌다.
  - 이 때 삽입, 삭제는 O(logN)을 따른다.
 
- log20 * 20 * 300만 = ?
  - 위 결과는 얼핏 잡아도 2.4억회다.
  - *컴퓨터는 1초에 간단한 연산을 약 1억 번 수행한다.*
  - 결론 : `std::set`을 쓰면 시간 제한 1.5초를 무조건 넘긴다.

## 비트 마스킹

문제에서 입력, 출력 예시에 많은 가정을 걸어주었다. '특정 구현'을 위한 난이도 배려 아닐까? 후훗.

- 입력되는 수 x는 1~20 뿐이다.
- x 검색 시 출력을 1, 0 으로 간단히 한다.
- '공집합'

> 비트 마스킹을 쓰라고 알려준 셈이다!

단순히 접근하면 **bool 배열**을 쓰려고 할 수도 있다. 그러나 bool type은 1byte다.

즉 숫자 하나당 1byte씩 필요하다.

그러나 비트 마스킹을 쓰면 숫자 하나당 1bit씩만 필요하다!

### 비트 표현

```cpp
int S = 0;
// 00000000 000000000 00000000 00000000
```
- 1은 0001
- 2는 0010
- 3은 0100
- 4는 1000

이런 식으로 비트 한 자리씩 쓰겠다.

### 비트 연산자

비트 마스킹을 하려면 당연히 **비트 연산자** 들을 알아야 한다.

- `&` AND 연산자
- `|` OR 연산자
- `~` NOT 연산자
- `^` XOR 연산자
- `<<`, `>>` Shift 연산자

이러한 연산자들에 기초적인 대한 설명은 생략한다.

### 비트 연산자 비트 마스킹 사용 tip

- `|=` OR 연산자(대입) : 해당 bit를 **삽입** 한다.
- `&= ~` AND 연산자(대입) + NOT 연산자 : 해당 bit를 **삭제** 한다.
- `&` AND 연산자 : 해당 bit **존재 유무 확인** 한다.

### 실전!

```cpp
// 공집합 생성
int S = 0;

// 원소 x 추가
S |= (1 << x);

// 원소 x 삭제
s &= ~(1 << x);

// 원소 x 체크
if (S & (1 << x)) cout << 'O' << endl;
else cout << 'X' << endl;

// all 추가
S |= (1 << 20) - 1;

// all 삭제 (clear)
S = 0;
```

다만 나의 경우 `1 = 0001` 로 사용하고 싶어서, x를 입력받은 이후에 모두 `x--`를 해준다.

(그래야 예를 들어 1의 경우 `1 << 0` 이 되어 S에 0001을 삽입하게 된다.)


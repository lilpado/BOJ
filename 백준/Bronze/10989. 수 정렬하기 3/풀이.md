# 단순 정렬 문제? No.

정렬이구나~ 뭐 이번엔 Quicksort 써볼까? `qsort()`

-> 즉시 메모리 초과

## 제한

> 항상 '시간 제한'과 '메모리 제한'을 유심히 볼 것

- 시간 제한 : 5초
- 메모리 제한 : 8MB (8,000,000 byte)

## 전제 조건

제한을 걸어둔 대신, 입력 조건에 뭔가 힌트를 남긴다.

- 첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다.
- 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.

개수가 10,000,000개 되는데 이것들을 전부 배열에 받는다? 분명 메모리 초과!

하지만 정말 중요한 내용이 있지. `주어지는 수는 10,000 이하` 

## 메모리 해결

> **Counting Sort** 를 알고 있니?

우리가 해야할 일은 개수만큼 출력하는 일 뿐이다. 그런데 꼭 값 하나하나 저장을 해야할까?

알파벳 개수를 `a[26]` 테이블에서 세어주는 것처럼, 숫자 개수를 `a[10000]` 테이블에서 세어준다면?

출력 작업을 충분히 하고도 메모리가 남는다는 것을 알 수 있다. (int type - 40000 byte)

## 시간 해결

> **빠른 입출력** 을 알고 있니?

메모리 초과는 해결이 되었으나, 이제는 '시간 초과'가 발목을 잡는다.

컴퓨터는 간단한 동작을 1초에 1억번 할 수 있다. 시간 제한 5초이니까 대략 5억번까지 가능.

지금까지의 방법대로 하면 loop가 3개 있다.

모두 합치면 최대 연산 횟수 = `10,000 + 10,000,000 + 10,009,999` 으로, 
단순 알고리즘의 문제만으로 치부하긴 애매한 상황이 되었다.

여기서 떠올랐다. 예전에 '새싹 문제' 에서 마주한 '빠른 입출력' 문제를..

### 빠른 입출력

> `cin, cout`은 `scanf, printf`보다 느리다.

#### 1) 만약 `cin, cout`을 쓰고싶다면,
```cpp
ios_base::sync_with_stdio(false); // C와 C++의 표준 stream의 동기화를 끊음
cin.tie(NULL); 
cout.tie(NULL); // cin과 cout의 tie를 끊어줌 (untie)
```
을 붙여줘야하고, `endl` 대신 개행문자 `\n`을 써야한다.

- C, C++의 표준 stream의 동기화를 끊음 : 동기화 상태가 default. 평소에는 C, C++ 입출력 방식을 제한 없이
 섞어서 사용 가능. 즉 C 버퍼 `stdio` 그리고 C++ 버퍼 `iostream` 모두 사용 및 동기화 상태 = 딜레이 발생 -> 따라서 동기화 해제.
- cin, cout tie 끊음 : cin, cout 서로 tie 상태가 default. 평소 서로 스트림에서 입출력 작업 하기 전 알잘딱으로
자동 flush. (Ex. cin 입력 작업 시작 직전 -> cout 출력 스트림 flush)

**주의**
위 두 사항으로 인해 생기는 주의사항
- C 입출력함수, C++ 입출력함수 섞어서 사용 X
- 멀티 쓰레드 주의! 동기화 해제 = Thread unsafe -> race condition 유발 (임계 구역에 동시 접근해 자원의 일관성이 깨진 상태)

#### 2) 모르겠고~ 그냥 `printf, scanf` 쓰겠다면,

그냥 대체하면 된다.
